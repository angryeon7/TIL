## 목차
1. RDB, NoSQL
   - [RDBMS ](#rdbms-관계형-데이터베이스)
   - [NoSQL ](#nosql)
   - [오라클과 MySQL의 차이는? ](#오라클과-mysql의-차이는)
   - [Commit과 Rollback이란? ](#commit과-rollback이란)
2. DBMS
   - [DBMS란 무엇인가요? ](#dbms란-무엇인가요)
   - [DBMS의 기능은 무엇인가요? ](#dbms의-기능은-무엇인가요)
   - [데이터베이스를 설계할 때 가장 중요한 것이 무엇이라고 생각하나요? ](#데이터베이스를-설계할-때-가장-중요한-것이-무엇이라고-생각하나요)
   - [데이터베이스 무결성이란? ](#데이터베이스-무결성이란)
   - [DB에서 View는 무엇인가? 가상 테이블이란? ](#db에서-view는-무엇인가-가상-테이블이란)
3. [정규화란? ](#정규화란)
4. [이상현상이란? ](#이상현상이란)
5. [트리거란? ](#트리거란)
6. [JDBC와 ODBC의 차이는? ](#jdbc와-odbc의-차이는)
7. 인덱스
   - [데이터 베이스에서 인덱스(색인)이란 무엇인가요 ](#데이터-베이스에서-인덱스색인이란-무엇인가요)
   - [B Tree ](#b-tree)
   - [B+ Tree ](#b-tree)

##  RDBMS (관계형 데이터베이스)
> 엄격하게 정해진 스키마 (Fields, Records의 제약 조건에 대한 명세)에 따라 데이터를 저장하기에 명확한 데이터 구조를 보장하는 데이터베이스이다.   
> 그렇기에 중복 데이터가 존재하지 않아 저장 공간을 절약할 수 있으며, 데이터 수정 (update)이 용이하다.   
> 그리고 테이블 간의 관계를 통해서 큰 규모의 데이터를 여러 개의 테이블 (ex. user, item, buying)에 분산 저장할 수 있다. 분산 저장을 통해 보안을 철저히 하고, 테이블를 구조적으로 도식화 함으로 효율적으로 관리할 수 있다. 다만, 테이블 관계가 복잡해 질수록 JOIN이 많은 SQL 쿼리가 만들어 질 수 있다.   
> 데이터 수정 (update)가 자주 발생하는 시스템이거나, 명확한 스키마가 중요한 경우 RDBMS가 적합하다.


## NoSQL
> NoSQL은 스키마없이 유연하게 데이터를 저장/관리할 수 있는 데이터베이스로 MongoDB가 대표적인 NoSQL이다.   
> 데이터 중복이 허용되기에 수정 (update)을 위해서는 중복으로 저장된 데이터를 검색하여 모두 수정해야하는 번거로움이 있으며, 엄격한 스키마가 없다보니 데이터에 대한 규격화된 결과 값을 얻을 수 없다.   
> 정확한 데이터 구조를 알지 못하거나, 데이터 수정 (update)보다는 쓰기 (write)와 읽기 (read)가 더 자주 발생하는 경우 NoSQL이 적합하다.   


[RDB]
Relational Database 관계형 데이터베이스.
엄격한 스키마와 테이블 형태로 데이터를 관리.
ex) MySQL, Oracle, PostgreSQL, SQLite

[NoSQL]
Not Only SQL 비관계형 데이터베이스.
테이블 형태가 아니고, 엄격하지 않은 Key-Value 형태로 데이터를 관리.
최근의 빅데이터 형태에서 많이 사용. Transaction과 SQL을 지원하지 않음.
ex) MongoDB, DynamoDB, Cassandra, Bigtable


## 오라클과 MySQL의 차이는?
> 일단 Oracle이 MySQL보다 훨~씬 좋음   
> 오라클 : 대규모 트랜잭션 로드를 처리하고, 성능 최적화를 위해 여러 서버에 대용량 DB를 분산함   
> MySQL : 단일 데이터베이스로 제한되어있고, 대용량 데이터베이스로는 부적합. 작은 프로젝트에서 적용시키기 용이하며 이전 상태를 복원하는데 commit과 rollback만 존재   


## Commit과 Rollback이란?
> Commit : 하나의 논리적 단위(트랜잭션)에 대한 작업이 성공적으로 끝났을 때, 이 트랜잭션이 행한 갱신 연산이 완료된 것을 트랜잭션 관리자에게 알려주는 연산

> Rollback : 하나의 트랜잭션 처리가 비정상적으로 종료되어 DB의 일관성을 깨뜨렸을 때, 모든 연산을 취소시키는 연산





## DBMS란 무엇인가요?
> Database = 모든 데이터들의 집합, 데이터의 모음을 데이터베이스라고 할 수 있다.    
> DataBase Management System = 데이터베이스를 관리하는 프로그램.    
> 사용자가 쿼리문을 작성하면, DBMS가 쿼리에 맞는 데이터를 찾아줍니다.   
> 다수의 사용자가 데이터베이스 내의 데이터를 접근할 수 있도록 설계된 시스템


## DBMS의 기능은 무엇인가요? 
> 정의 기능(DDL: Data Definition Language)   
> 데이터베이스가 어떤 용도이며 어떤 식으로 이용될것이라는 것에 대한 정의가 필요함
> - CREATE, ALTER, DROP, RENAME

> 조작 기능(DML: Data Manipulation Language)   
> 데이터베이스를 만들었을 때 그 정보를 수정하거나 삭제 추가 검색 할 수 있어야함   
> - SELECT, INSERT, UPDATE, DELETE

> 제어 기능(DCL: Data Control Language)   
> 데이터베이스에 접근하고 객체들을 사용하도록 권한을 주고 회수하는 명령   
> - GRANT REVOKE


## 데이터베이스를 설계할 때 가장 중요한 것이 무엇이라고 생각하나요?
> 무결성을 보장해야 합니다.

> 무결성 보장 방법은?
> 데이터를 조작하는 프로그램 내에서 데이터 생성, 수정, 삭제 시 무결성 조건을 검증한다.   
> 트리거 이벤트 시 저장 SQL을 실행하고 무결성 조건을 실행한다.   
> DB제약조건 기능을 선언한다.


### 데이터베이스 무결성이란?
> 테이블에 있는 모든 행들이 유일한 식별자를 가질 것을 요구함 (같은 값 X)   
> 외래키 값은 NULL이거나 참조 테이블의 PK값이어야 함   
> 한 컬럼에 대해 NULL 허용 여부와 자료형, 규칙으로 타당한 데이터 값 지정
>

## DB에서 View는 무엇인가? 가상 테이블이란?
> 허용된 데이터를 제한적으로 보여주기 위한 것    
> 하나 이상의 테이블에서 유도된 가상 테이블이다.   
> 사용자가 view에 접근했을 때 해당하는 데이터를 원본에서 가져온다.   
> view에 나타나지 않은 데이터를 간편히 보호할 수 있는 장점 존재
> 뷰 = 어떠한 테이블을 기반으로 만들어진 가상 테이블. 물리적인 공간을 차지하지 않는다.
> CREATE VIEW 명령어로 생성한다.

> 테이블을 어떠한 조건을 입혀서 제한적으로 보여주기 위해 많이 사용한다.

> 결국은 테이블에 의존적이라서 테이블이 삭제되면 뷰도 삭제된다.

> SELECT, INSERT, UPDATE, DELETE 문 모두 기본 테이블을 기반으로 일어난다.

#### 뷰를 사용하는 이유
SQL문을 더 쉽게 작성할 수 있다.   
복잡한 조건을 만족하는 뷰를 만들어두면, 매번 SQL문을 어렵게 작성할 필요없이 뷰에 접근하면 된다.

데이터 보안 유지에 도움이 된다.   
여러가지 사용자의 요구에 맞는 다양한 뷰를 미리 만들어두고, 사용자가 자신에게 제공된 뷰를 통해서만 데이터에 접근하도록 권한 설정을 하면, 뷰에 포함되지 않은 데이터를 사용자로부터 보호할 수 있다.   
데이터의 일부만 열람할 수 있도록 허용하는 것.




## 정규화란?
> 이상 현상을 제거하기 위해 데이터베이스의 데이터를 분해하는 과정.    
> 중복된 데이터가 저장되는 것을 방지하고, INSERT, UPDATE, DELETE 할 때 이상한 현상이 생기는 것을 방지하기 위해서 정규화를 한다.




## 이상현상이란?
> 불필요한 데이터 중복으로 인해 삽입, 갱신, 삭제 연산을 할때 발생할 수 있는 부작용
> 1. 삽입 이상   
> 데이터를 삽입하기 위해 불필요한 데이터도 함께 삽입해야 하는 문제.

> 2. 갱신 이상   
> 중복 튜플 중 일부만 변경해서 데이터 불일치가 생기는 문제.

> 3. 삭제 이상   
> 튜플을 삭제하면 꼭 필요한 데이터까지 함께 삭제되는 데이터 손실 문제.



### 트리거란?
> 자동으로 실행되도록 정의된 저장 프로시저    
> (insert, update, delete문에 대한 응답을 자동으로 호출한다.)

> ##### 사용하는 이유는?
> 업무 규칙 보장, 업무 처리 자동화, 데이터 무결성 강화



## JDBC와 ODBC의 차이는?
> JDBC > 자바에서 DB에 접근하여 데이터를 조회, 삽입, 수정, 삭제 가능 > DBMS 종류에 따라 맞는 jdbc를 설치해야함   
> ODBC > 응용 프로그램에서 DB 접근을 위한 표준 개방형 응용 프로그램 인터페이스 > MS사에서 만들었으며, Excel/Text 등 여러 종류의 데이터에 접근할 수 있음

## 데이터 베이스에서 인덱스(색인)이란 무엇인가요
> 인덱스 = 데이터베이스에서 table의 검색 성능을 향상 시켜주는 자료구조. 대부분 B+ Tree로 되어있다.   
> DBMS에서 저장 성능을 희생하여 데이터 읽기 속도를 높이는 기능   
> 데이터가 정렬되어 들어간다   
> 양이 많은 테이블에서 일부 데이터만 불러 왔을 때, 이를 풀 스캔 시 처리 성능 떨어짐   
> 종류     
>> B+-Tree 인덱스 : 원래의 값을 이용하여 인덱싱
>> - Hash 인덱스 : 칼럼 값으로 해시 값 게산하여 인덱싱, 메모리 기반 DB에서 많이 사용
>> - B>Hash
>>> 생성시 고려해야 할 점   
>>> - 테이블 전체 로우 수 15%이하 데이터 조회시 생성   
>>> - 테이블 건수가 적으면 인덱스 생성 하지 않음, 풀 스캔이 빠름
>>> - 자주 쓰는 컬럼을 앞으로 지정
>>> - DML시 인덱스에도 수정 작업이 동시에 발생하므로 DML이 많은 테이블은 인덱스 생성 하지 않음

### 인덱스란(추가설명)
특정 column 을 search-key 값으로 설정하고, search-key 를 기준으로 정렬하여 (search-key, pointer)를 별도의 파일에 저장한다.   
search-key = 인덱스에 저장되는 column 속성   
pointer = 데이터가 실제로 저장되는 물리적인 위치   
Full Table Scan 보다 Index Scan 이 훨씬 빠르기 때문에 그 column 에 대한 검색 속도를 향상 시킬 수 있다.   
CREATE INDEX 문으로 생성   

클러스터형 인덱스 = 테이블 자체가 하나의 인덱스처럼 정렬되는 것. 예를들어 학번으로 정렬된 테이블.   
보조형 인덱스 = 테이블과 별개로 search-key, pointer 자료구조 인덱스를 만드는 것   

#### 인덱스의 장단점
###### 장점
검색 속도 향상 (SELECT WHERE)    
###### 단점
추가적인 저장공간 필요   
검색에는 성능향상이 되지만, 데이터 수정이 자주 발생하면 성능저하. 트리 구조를 재구성해야하기 때문.   

##### 그럼 index는 어떤 column에 사용하는 것이 좋을까요?
- 자주 조회
- 수정 빈도 낮은
- 카디널리티 높은 (데이터가 중복되지 않는 정도가 높은, 예를들어 주민번호는 카디널리티 높음)
- 그냥 자주 조회되고, 수정 잘 안되고, 중복이 적은 컬럼에 사용하는게 좋다.
- 데이터 양 자체가 적을 때보단 양이 많을 때 사용하는 것이 좋다.

### B Tree
- B Tree 는 Balanced Tree. 모든 리프들이 같은 레벨을 가질 수 있도록 한다.
- 하나의 노드에 여러 개의 key와 Pointer 를 가질 수 있다. (파란색은 key / 빨간색은 Pointer)
- 정렬된 순서를 보장한다.
- 멀티레벨 인덱싱을 통한 빠른 검색을 할 수 있다.
- 실제 DB에서는 B Tree에서 발전된 B+ Tree를 많이 사용한다.
  
### B+ Tree
###### B Tree 와의 공통점
- 하나의 노드에 여러 개의 Key와 Pointer 를 가질 수 있다.
- 정렬된 순서를 보장한다.
- 멀티레벨 인덱싱을 통한 빠른 검색을 할 수 있다.

###### B Tree 와의 차이점
- 모든 key, data가 리프에 모여있다. (리프까지 가야만 데이터 탐색 가능)
- 모든 리프노드가 연결리스트 형태를 가진다.

###### B+ Tree가 DB Index로 적합한 자료구조인 이유
- 데이터가 정렬되어있기 때문에 부등호 연산에 유리하다.
- 검색 / 삽입 / 수정 / 삭제 모두 O(logN) 소요된다.








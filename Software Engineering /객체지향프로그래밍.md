# 객체지향 프로그래밍

### 절차적, 구조적 프로그래밍

반복될 가능성이 있는 것들을 재사용이 가능한 함수(프로시저)로 만들어 사용하는 프로그래밍 방식.

절차 -> 함수(프로시저)를 뜻하고, 구조는 모듈을 뜻한다.

### 프로시저란?

> 반환값(리턴)이 따로 존재하지 않는 함수를 뜻한다.
> 
> 
> 예를 들면, printf와 같은 함수는 반환값을 얻기 위한 것보단, 화면에 출력하는 용도로 쓰이는 함수다.
> 

## 객체 지향 프로그램

객체지향으로 구현하게 되면, 객체 간의 독립성이 생기고 중복코드의 양이 줄어드는 장점이 있다.

또한 독립성이 확립되면 유지보수에도 도움이 될 것이다.

### 특징

**1. 추상화(Abstraction)**

```
   필요로 하는 속성이나 행동을 추출하는 작업
   세부적인 사물들의 공통적인 특징을 파악한 후 하나의 집합으로 만들어내는 것
   ex. 사과, 바나나, 딸기는 모두 '과일'라는 공통점이 있다.
   과일이라는 추상화 집합을 만들어두고, 과일들이 가진 공통적인 특징들을 만들어 활용한다.

```

**2. 캡슐화(Encapsulation)**

```
   낮은 결합도를 유지할 수 있도록 설계하는 것

```

> 캡슐화는 어떻게 높은 응집도와 낮은 결합도를 유지 ->  정보 은닉
> 
> 
> 외부에서 접근할 필요가 없는 것들은 private으로 접근하지 못하도록 제한
> 

**3. 상속**

```
    일반화 관계(Generalization)라고도 하며, 여러 개체들이 지닌 공통된 특성을 부각시켜 하나의 개념이나 법칙으로 성립하는 과정
    일반화(상속)은 또 다른 캡슐화다.
    자식 클래스를 외부로부터 은닉하는 캡슐화의 일종

```

> 사료를 만드는 사람 클래스가 있다고 생각해보자. 이때, 강아지의 자식 클래스에 해당하는 불독, 푸들, 시바견 등은 캡슐화를 통해 은닉해둔 상태다.
> 

> 사람 클래스의 관점으로는, 구체적인 강아지의 종류가 숨겨져 있는 상태다. 사료 사장 입장에서는 강아지의 종류가 어떤 것인지는 사료를 만드는데 크게 중요하지 않다.
> 

> 새로운 강아지들이 추가된다고 해도, 사람 클래스는 영향을 받지 않는 것이 중요하다. 그러므로 캡슐화를 통해 사람 클래스 입장에서는 확인할 수 없도록 구현하는 것이다.
> 

> ! 상속 재사용의 단점    

>> 상위 클래스(부모 클래스)의 변경이 어려워진다.    
>> 불필요한 클래스가 증가할 수 있다.    
>> 유사기능 확장시, 필요 이상의 불필요한 클래스를 만들어야 하는 상황이 발생할 수 있다.   
> 

>> 상속이 잘못 사용될 수 있다.    
>> 같은 종류가 아닌 클래스의 구현을 재사용하기 위해 상속을 받게 되면, 문제가 발생할 수 있다.

> ! 그럼 상속은 언제 사용?
> 
> 
> > -> 재사용 관점이 아닌, 기능의 확장 관점일 때
> > 

**3. 다형성(Polymorphism)**

```
    서로 다른 클래스의 객체가 같은 메시지를 받았을 때 각자의 방식으로 동작하는 능력
    다형성은, 상속과 함께 활용할 때 큰 힘을 발휘한다. 이와 같은 구현은 코드를 간결하게 해주고, 유연함을 갖추게 해준다.
    즉, 부모 클래스의 메소드를 자식 클래스가 오버라이딩해서 자신의 역할에 맞게 활용하는 것이 다형성이다.

    상속 관계에 있으면, 새로운 자식 클래스가 추가되어도 부모 클래스의 함수를 참조해오면 되기 때문에 다른 클래스는 영향을 받지 않게 된다.

```

## SOLID

**객체 지향 설계 원칙 5가지**

##### 1. SRP(Single Responsibility) - 단일 책임 원칙

- 클래스는 단 한 개의 책임을 가져야 한다.
- 클래스를 변경하는 이유는 단 한개여야 한다.
- 하나의 책임이 여러 개의 클래스에 분산되어서는 안된다.
- 하나의 클래스 안에 협력관계가 여러 개 있는 것은 괜찮다.

##### 2. OCP(Open-Closed) - 개방-폐쇄 원칙

- 확장에는 열려 있어야 하고, 변경에는 닫혀 있어야 한다.
- 기능을 변경하거나 확장할 수 있으면서 그 기능을 사용하는 코드는 수정하지 않는다.
- 모듈이 주변 환경에 지나치게 의존해서는 안된다.

##### 3. LSP(Liskov Substitution) - 리스코프 치환 원칙

- 부모 객체를 호출하는 동작에서 자식 객체가 부모 객체를 완전히 대체할 수 있다는 원칙이다.
- 자식 클래스는 부모 클래스의 동작을 바꾸지 않는다.
- 하위 타입인 자식 객체는 상위 타입인 부모 객체의 특성을 가지며, 그 특성을 토대로 확장할 수 있다.

##### 4. ISP(Interface Segregation) - 인터페이스 분리 원칙

- 인터페이스는 그 인터페이스를 사용하는 클라이언트를 기준으로 분리해야 한다.
- 각 클라이언트가 필요로 하는 인터페이스들을 분리함으로써, 각 클라이언트가 사용하지 않는 인터페이스에 변경이 발생하더라도 영향을 받지 않도록 만들어야 한다.
- 인터페이스가 커지면 SRP가 지켜지지 않고, 해당 인터페이스를 채택해서 사용하는 경우 쓰지 않는 메소드가 있어도 구현해야하는 경우가 발생

##### 5. DIP(Dependency Inversion) - 의존 역전 원칙

- 상위레벨(추상화 수준이 높은, 추상적인) 모듈은 하위레벨(추상화 수준이 낮은, 구체적인) 모듈에 의존하면 안된다.
- 저수준 모듈이 고수준 모듈에서 정의한 추상 타입에 의존해야 한다. 즉, 저수준 모듈이 변경돼도 고수준 모듈은 변경할 필요가 없는 것이다.
- 변화하기 쉬운 것, 자주 변하는 것(Clean Architecture에서 Repository같은)보다는 변화가 거의 없는 것에 의존해야 한다.
- 만약 상위레벨이 하위레벨에 의존하는 경우 제네릭이나 Associate 를 사용한다.
    - 연관타입(associate type) 활용
    - Generic에 나오는 개념 중 하나로, 진짜 type을 주는게 아니라 그 어떤 타입이여도 상관 없지만 하나의 타입임은 분명하다는 명시적 의미
